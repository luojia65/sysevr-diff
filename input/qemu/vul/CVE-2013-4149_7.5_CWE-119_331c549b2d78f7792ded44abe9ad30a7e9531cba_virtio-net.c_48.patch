--- CVE-2013-4149_7.5_CWE-119_331c549b2d78f7792ded44abe9ad30a7e9531cba_virtio-net.c_48_OLD.vul	2020-05-20 08:47:31.950673619 -0400
+++ CVE-2013-4149_7.5_CWE-119_331c549b2d78f7792ded44abe9ad30a7e9531cba_virtio-net.c_48_NEW.vul	2020-05-20 08:47:31.950673619 -0400
@@ -36,10 +36,17 @@
         if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {
             qemu_get_buffer(f, n->mac_table.macs,
                             n->mac_table.in_use * ETH_ALEN);
-        } else if (n->mac_table.in_use) {
-            uint8_t *buf = g_malloc0(n->mac_table.in_use);
-            qemu_get_buffer(f, buf, n->mac_table.in_use * ETH_ALEN);
-            g_free(buf);
+        } else {
+            int64_t i;
+
+            /* Overflow detected - can happen if source has a larger MAC table.
+             * We simply set overflow flag so there's no need to maintain the
+             * table of addresses, discard them all.
+             * Note: 64 bit math to avoid integer overflow.
+             */
+            for (i = 0; i < (int64_t)n->mac_table.in_use * ETH_ALEN; ++i) {
+                qemu_get_byte(f);
+            }
             n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;
             n->mac_table.in_use = 0;
         }
