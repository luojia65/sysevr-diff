--- CVE-2017-15124_7.8_CWE-020_f887cf165db20f405cb8805c716bd363aaadf815_vnc.c_57_OLD.vul	2020-05-20 08:42:02.102947977 -0400
+++ CVE-2017-15124_7.8_CWE-020_f887cf165db20f405cb8805c716bd363aaadf815_vnc.c_57_NEW.vul	2020-05-20 08:42:02.102947977 -0400
@@ -1,5 +1,25 @@
 void vnc_write(VncState *vs, const void *data, size_t len)
 {
+    if (vs->disconnecting) {
+        return;
+    }
+    /* Protection against malicious client/guest to prevent our output
+     * buffer growing without bound if client stops reading data. This
+     * should rarely trigger, because we have earlier throttling code
+     * which stops issuing framebuffer updates and drops audio data
+     * if the throttle_output_offset value is exceeded. So we only reach
+     * this higher level if a huge number of pseudo-encodings get
+     * triggered while data can't be sent on the socket.
+     *
+     * NB throttle_output_offset can be zero during early protocol
+     * handshake, or from the job thread's VncState clone
+     */
+    if (vs->throttle_output_offset != 0 &&
+        vs->output.offset > (vs->throttle_output_offset *
+                             VNC_THROTTLE_OUTPUT_LIMIT_SCALE)) {
+        vnc_disconnect_start(vs);
+        return;
+    }
     buffer_reserve(&vs->output, len);
 
     if (vs->ioc != NULL && buffer_empty(&vs->output)) {
