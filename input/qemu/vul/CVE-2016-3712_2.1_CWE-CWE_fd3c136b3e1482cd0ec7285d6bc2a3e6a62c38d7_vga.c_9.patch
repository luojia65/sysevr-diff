--- CVE-2016-3712_2.1_CWE-CWE_fd3c136b3e1482cd0ec7285d6bc2a3e6a62c38d7_vga.c_9_OLD.vul	2020-05-20 08:39:03.897576490 -0400
+++ CVE-2016-3712_2.1_CWE-CWE_fd3c136b3e1482cd0ec7285d6bc2a3e6a62c38d7_vga.c_9_NEW.vul	2020-05-20 08:39:03.897576490 -0400
@@ -55,6 +55,7 @@
         printf("vga: write SR%x = 0x%02x\n", s->sr_index, val);
 #endif
         s->sr[s->sr_index] = val & sr_mask[s->sr_index];
+        vbe_update_vgaregs(s);
         if (s->sr_index == VGA_SEQ_CLOCK_MODE) {
             s->update_retrace_info(s);
         }
@@ -86,6 +87,7 @@
         printf("vga: write GR%x = 0x%02x\n", s->gr_index, val);
 #endif
         s->gr[s->gr_index] = val & gr_mask[s->gr_index];
+        vbe_update_vgaregs(s);
         vga_update_memory_access(s);
         break;
     case VGA_CRT_IM:
@@ -104,10 +106,12 @@
             if (s->cr_index == VGA_CRTC_OVERFLOW) {
                 s->cr[VGA_CRTC_OVERFLOW] = (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) |
                     (val & 0x10);
+                vbe_update_vgaregs(s);
             }
             return;
         }
         s->cr[s->cr_index] = val;
+        vbe_update_vgaregs(s);
 
         switch(s->cr_index) {
         case VGA_CRTC_H_TOTAL:
