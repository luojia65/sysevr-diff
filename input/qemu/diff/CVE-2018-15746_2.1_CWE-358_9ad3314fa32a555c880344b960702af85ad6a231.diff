commit 9ad3314fa32a555c880344b960702af85ad6a231
Author:     Marc-André Lureau <marcandre.lureau@redhat.com>
AuthorDate: Wed Aug 22 19:02:48 2018 +0200
Commit:     Michael Roth <mdroth@linux.vnet.ibm.com>
CommitDate: Tue Apr 2 13:11:03 2019 -0500

    seccomp: prefer SCMP_ACT_KILL_PROCESS if available
    
    The upcoming libseccomp release should have SCMP_ACT_KILL_PROCESS
    action (https://github.com/seccomp/libseccomp/issues/96).
    
    SCMP_ACT_KILL_PROCESS is preferable to immediately terminate the
    offending process, rather than having the SIGSYS handler running.
    
    Use SECCOMP_GET_ACTION_AVAIL to check availability of kernel support,
    as libseccomp will fallback on SCMP_ACT_KILL otherwise, and we still
    prefer SCMP_ACT_TRAP.
    
    Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
    Reviewed-by: Daniel P. Berrangé <berrange@redhat.com>
    Acked-by: Eduardo Otubo <otubo@redhat.com>
    (cherry picked from commit bda08a5764d470f101fa38635d30b41179a313e1)
    *CVE-2018-15746
    Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

diff --git a/qemu-seccomp.c b/qemu-seccomp.c
index b117a92559..f0c833f3ca 100644
--- a/qemu-seccomp.c
+++ b/qemu-seccomp.c
@@ -20,6 +20,7 @@
 #include <sys/prctl.h>
 #include <seccomp.h>
 #include "sysemu/seccomp.h"
+#include <linux/seccomp.h>
 
 /* For some architectures (notably ARM) cacheflush is not supported until
  * libseccomp 2.2.3, but configure enforces that we are using a more recent
@@ -107,12 +108,40 @@ static const struct QemuSeccompSyscall blacklist[] = {
     { SCMP_SYS(sched_get_priority_min), QEMU_SECCOMP_SET_RESOURCECTL },
 };
 
+static inline __attribute__((unused)) int
+qemu_seccomp(unsigned int operation, unsigned int flags, void *args)
+{
+#ifdef __NR_seccomp
+    return syscall(__NR_seccomp, operation, flags, args);
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+static uint32_t qemu_seccomp_get_kill_action(void)
+{
+#if defined(SECCOMP_GET_ACTION_AVAIL) && defined(SCMP_ACT_KILL_PROCESS) && \
+    defined(SECCOMP_RET_KILL_PROCESS)
+    {
+        uint32_t action = SECCOMP_RET_KILL_PROCESS;
+
+        if (qemu_seccomp(SECCOMP_GET_ACTION_AVAIL, 0, &action) == 0) {
+            return SCMP_ACT_KILL_PROCESS;
+        }
+    }
+#endif
+
+    return SCMP_ACT_TRAP;
+}
+
 
 static int seccomp_start(uint32_t seccomp_opts)
 {
     int rc = 0;
     unsigned int i = 0;
     scmp_filter_ctx ctx;
+    uint32_t action = qemu_seccomp_get_kill_action();
 
     ctx = seccomp_init(SCMP_ACT_ALLOW);
     if (ctx == NULL) {
@@ -125,7 +154,7 @@ static int seccomp_start(uint32_t seccomp_opts)
             continue;
         }
 
-        rc = seccomp_rule_add_array(ctx, SCMP_ACT_TRAP, blacklist[i].num,
+        rc = seccomp_rule_add_array(ctx, action, blacklist[i].num,
                                     blacklist[i].narg, blacklist[i].arg_cmp);
         if (rc < 0) {
             goto seccomp_return;
